package dev._3000IQPlay.trillium.modules.exploit;

import dev._3000IQPlay.trillium.event.events.PlayerMoveEvent;
import dev._3000IQPlay.trillium.event.events.PacketEvent;
import dev._3000IQPlay.trillium.modules.Module;
import dev._3000IQPlay.trillium.modules.movement.Speed;
import dev._3000IQPlay.trillium.setting.Setting;
import dev._3000IQPlay.trillium.mixin.mixins.INetworkManager;
import dev._3000IQPlay.trillium.mixin.mixins.ISPacketPlayerPosLook;
import dev._3000IQPlay.trillium.util.MovementUtil;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.util.HashMap;
import java.util.Map;

public class PacketFly
        extends Module {
    public static PacketFly INSTANCE;
	public Setting<Mode> mode = this.register(new Setting<Mode>("Mode", Mode.FACTOR));
    public Setting<Float> factor = this.register(new Setting<Float>("Factor", Float.valueOf(1.0f), Float.valueOf(0.1f), Float.valueOf(15.0f), v -> this.mode.getValue() == Mode.FACTOR));
    public Setting<Integer> increaseTicks = this.register(new Setting<Integer>("IncreaseTicks", 10, 0, 20));
	public Setting<Bounds> bounds = this.register(new Setting<Bounds>("Bounds", Bounds.DOWN));
    public Setting<Phase> phase = this.register(new Setting<Phase>("Phase", Phase.NCP));
    public Setting<Boolean> conceal = this.register(new Setting<Boolean>("Conceal", false));
    public Setting<Boolean> antiKick = this.register(new Setting<Boolean>("AntiKick", true));
	public Setting<Integer> fallTicks = this.register(new Setting<Integer>("FallTicks", 10, 0, 40, v -> this.antiKick.getValue()));
    private final Map<Integer, Vec3d> predictions = new HashMap<Integer, Vec3d>();
    private int tpId = 0;
    private int lagTime = 0;
    private static final double MOVE_FACTOR;
    private static final double CONCEAL = 0.0624;
	
	public PacketFly() {
        super("PacketFly", "Uses packets to allow you to fly and move.", Module.Category.EXPLOIT, true, false, false);
		INSTANCE = this;
    }

    private void send(int n, double d, double d2, boolean bl) {
        if (n == 0) {
            PacketFly.mc.player.setVelocity(0.0, 0.0, 0.0);
            return;
        }
        double[] arrd = PacketFly.getMoveSpeed(d);
        for (int i = 1; i < n + 1; ++i) {
            double d3 = arrd[0] * (double)i;
            double d4 = arrd[1] * (double)i;
            double d5 = d2;
            if (!bl) {
                d5 *= (double)i;
            }
            PacketFly.mc.player.motionX = d3;
            PacketFly.mc.player.motionY = d5;
            PacketFly.mc.player.motionZ = d4;
            Vec3d vec3d = PacketFly.mc.player.getPositionVector();
            Vec3d vec3d2 = vec3d.add(d3, d5, d4);
            this.send(vec3d2);
            this.send(this.bounds.getValue().modify(vec3d));
            if (this.mode.getValue().equals((Object)Mode.SETBACK)) continue;
            this.predictions.put(++this.tpId, vec3d2);
            PacketFly.mc.player.connection.sendPacket((Packet)new CPacketConfirmTeleport(this.tpId));
        }
    }

    @SubscribeEvent(priority=EventPriority.HIGH)
    public void onPacketReceive(PacketEvent.Receive event) {
        if (event.getPacket() instanceof SPacketPlayerPosLook) {
            SPacketPlayerPosLook sPacketPlayerPosLook = (SPacketPlayerPosLook)event.getPacket();
            Vec3d vec3d = this.predictions.get(sPacketPlayerPosLook.getTeleportId());
            if (vec3d != null && vec3d.x == sPacketPlayerPosLook.getX() && vec3d.y == sPacketPlayerPosLook.getY() && vec3d.z == sPacketPlayerPosLook.getZ()) {
                if (!this.mode.getValue().equals((Object)Mode.SETBACK)) {
                    event.setCanceled(true);
                }
                PacketFly.mc.player.connection.sendPacket((Packet)new CPacketConfirmTeleport(sPacketPlayerPosLook.getTeleportId()));
                return;
            }
            ((ISPacketPlayerPosLook)sPacketPlayerPosLook).setYaw(PacketFly.mc.player.rotationYaw);
            ((ISPacketPlayerPosLook)sPacketPlayerPosLook).setPitch(PacketFly.mc.player.rotationPitch);
            PacketFly.mc.player.connection.sendPacket((Packet)new CPacketConfirmTeleport(sPacketPlayerPosLook.getTeleportId()));
            this.lagTime = 10;
            this.tpId = sPacketPlayerPosLook.getTeleportId();
        }
    }

    private boolean isPhased() {
        return !PacketFly.mc.world.getCollisionBoxes((Entity)PacketFly.mc.player, PacketFly.mc.player.getEntityBoundingBox().expand(-0.0625, -0.0625, -0.0625)).isEmpty();
    }

    @SubscribeEvent
    public void onPlayerMoveEvent(PlayerMoveEvent event) {
        int n = (int)Math.floor(this.factor.getValue().floatValue());
        if (this.mode.getValue().equals((Object)Mode.FACTOR)) {
            if ((double)PacketFly.mc.player.ticksExisted % this.increaseTicks.getValue().intValue() < this.increaseTicks.getValue().intValue() * ((double)this.factor.getValue().floatValue() - Math.floor(this.factor.getValue().floatValue()))) {
                ++n;
            }
        } else {
            n = 1;
        }
        double d = this.conceal.getValue() != false || --this.lagTime > 0 || this.isPhased() ? 0.0624 : 0.2873;
        double d2 = 0.0;
        boolean bl = false;
        if (PacketFly.mc.gameSettings.keyBindJump.isKeyDown()) {
            d2 = 0.0624;
            if (MovementUtil.isMoving((EntityLivingBase) Speed.mc.player)) {
                d *= MOVE_FACTOR;
                d2 *= MOVE_FACTOR;
            }
        } else if (PacketFly.mc.gameSettings.keyBindSneak.isKeyDown()) {
            d2 = -0.0624;
            if (MovementUtil.isMoving((EntityLivingBase)Speed.mc.player)) {
                d *= MOVE_FACTOR;
                d2 *= MOVE_FACTOR;
            }
        } else {
            boolean bl2 = bl = this.antiKick.getValue() != false && PacketFly.mc.player.ticksExisted % this.fallTicks.getValue().intValue() == 0 && !this.isPhased() && !PacketFly.mc.world.collidesWithAnyBlock(PacketFly.mc.player.getEntityBoundingBox()) && !MovementUtil.isMoving((EntityLivingBase)Speed.mc.player);
            if (bl) {
                n = 1;
                d2 = -0.04;
            }
        }
        this.send(n, d, d2, bl);
        event.setX(PacketFly.mc.player.motionX);
        event.setY(PacketFly.mc.player.motionY);
        event.setZ(PacketFly.mc.player.motionZ);
        if (!this.phase.getValue().equals((Object)Phase.NONE)) {
            PacketFly.mc.player.noClip = true;
        }
    }

    @Override
    public void onLogout() {
        this.disable();
    }

    @Override
    public void onDisable() {
        super.onDisable();
        this.predictions.clear();
        this.tpId = 0;
        this.lagTime = 0;
        PacketFly.mc.player.noClip = false;
    }

    private void send(Vec3d vec3d) {
        ((INetworkManager)PacketFly.mc.player.connection.getNetworkManager()).hookDispatchPacket((Packet<?>)new CPacketPlayer.Position(vec3d.x, vec3d.y, vec3d.z, true), null);
    }

    static {
        MOVE_FACTOR = 1.0 / StrictMath.sqrt(2.0);
    }

    @SubscribeEvent(priority=EventPriority.HIGH)
    public void onPacketSend(PacketEvent.Send send) {
        if (send.getPacket() instanceof CPacketPlayer) {
            send.setCanceled(true);
        }
    }

    public static enum Bounds {
        UP(1337.0),
        DOWN(-1337.0),
        MIN(512.0);
        private final double yOffset;
        public Vec3d modify(Vec3d vec3d) {
            return vec3d.add(0.0, this.yOffset, 0.0);
        }
        private Bounds(double d) {
            this.yOffset = d;
        }
    }
	
	public static double[] getMoveSpeed(double d) {
        float f = PacketFly.mc.player.movementInput.moveForward;
        float f2 = PacketFly.mc.player.movementInput.moveStrafe;
        float f3 = PacketFly.mc.player.rotationYaw;
        if (f != 0.0f) {
            if (f2 >= 1.0f) {
                f3 += (float)(f > 0.0f ? -45 : 45);
                f2 = 0.0f;
            } else if (f2 <= -1.0f) {
                f3 += (float)(f > 0.0f ? 45 : -45);
                f2 = 0.0f;
            }
            if (f > 0.0f) {
                f = 1.0f;
            } else if (f < 0.0f) {
                f = -1.0f;
            }
        }
        double d2 = Math.sin(Math.toRadians(f3 + 90.0f));
        double d3 = Math.cos(Math.toRadians(f3 + 90.0f));
        double d4 = (double)f * d * d3 + (double)f2 * d * d2;
        double d5 = (double)f * d * d2 - (double)f2 * d * d3;
        if (!PacketFly.isMovingMomentum()) {
            d4 = 0.0;
            d5 = 0.0;
        }
        return new double[]{d4, d5};
    }
	
	public static boolean isMovingMomentum() {
        return (double)PacketFly.mc.player.moveForward != 0.0 || (double)PacketFly.mc.player.moveStrafing != 0.0;
    }
	
	public static enum Mode {
        FACTOR,
        FAST,
        SETBACK;
    }

    public static enum Phase {
        NONE,
        VANILLA,
        NCP;
    }
}