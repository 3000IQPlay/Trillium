package dev._3000IQPlay.trillium.modules.exploit;

import dev._3000IQPlay.trillium.modules.Module;
import dev._3000IQPlay.trillium.event.events.PacketEvent;
import net.minecraft.entity.item.EntityEnderCrystal;
import net.minecraft.init.SoundEvents;
import net.minecraft.network.Packet;
import net.minecraft.network.play.server.SPacketExplosion;
import net.minecraft.network.play.server.SPacketSoundEffect;
import net.minecraft.util.SoundCategory;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.util.ArrayList;

public class CrystalOptimizer
        extends Module {
	public CrystalOptimizer() {
        super("CrystalOptimizer", "Removes exploded crystals client-side to prevent desyncs", Module.Category.EXPLOIT, true, false, false);
    }

    @SubscribeEvent
    public void onPacketReceive(PacketEvent.Receive event) {
        Packet<?> packet = event.getPacket();
        Vec3d explosionVec = null;
        double range = 0.0;

        if (packet instanceof SPacketExplosion) {
            SPacketExplosion explosionPacket = (SPacketExplosion) packet;
            explosionVec = new Vec3d(explosionPacket.getX(), explosionPacket.getY(), explosionPacket.getZ());
            range = explosionPacket.getStrength();
        }
        else if (packet instanceof SPacketSoundEffect
                && ((SPacketSoundEffect) packet).getSound() == SoundEvents.ENTITY_GENERIC_EXPLODE
                && ((SPacketSoundEffect) packet).getCategory() == SoundCategory.BLOCKS) {
            SPacketSoundEffect soundPacket = (SPacketSoundEffect) packet;
            explosionVec = new Vec3d(soundPacket.getX(), soundPacket.getY(), soundPacket.getZ());
            range = 11.0;
        }

        if (explosionVec == null)
            return;

        Vec3d finalExplosionVec = explosionVec;
        double finalRange = range;
        new ArrayList<>(mc.world.loadedEntityList).parallelStream()
                .filter(entity -> !entity.isDead
                        && entity instanceof EntityEnderCrystal
                        && CrystalOptimizer.isWithinRange(finalExplosionVec.add(0.5, 0.5, 0.5), entity.getPositionVector(), finalRange))
                .forEach(entity -> {
                    entity.setDead();
                    mc.world.removeEntity(entity);
                });
    }
	
	public static boolean isWithinRange(Vec3d start, Vec3d end, double range) {
        double x = end.x - start.x;
        double y = end.y - start.y;
        double z = end.z - start.z;
        return (x * x) + (y * y) + (z * z) <= range * range;
    }
}